// Underwater screen distortion effect with dynamic turbulence map
// Designed for URP Fullscreen Pass (using Blit)
Shader "Examples/UnderwaterDistortionHLSL"
{
    Properties
    {
        // _MainTex is the screen texture provided by the Blit command
        _MainTex ("Screen Texture", 2D) = "white" {}

        // Noise texture for the base wave effect
        _NoiseTex ("Noise Texture (R Channel)", 2D) = "gray" {}

        // Turbulence map generated by the second camera
        _TurbulenceMap ("Turbulence Map (R Channel)", 2D) = "black" {}

        // Control parameters
        _BaseDistortionStrength ("Base Distortion Strength", Range(0.0, 0.1)) = 0.01
        _NoiseScale ("Noise Scale", Float) = 10.0
        _NoiseSpeed ("Noise Speed", Float) = 0.5
        _TurbulenceMultiplier ("Turbulence Multiplier", Range(0.0, 0.2)) = 0.05
    }

    SubShader
    {
        // Required URP tags
        Tags { "RenderPipeline" = "UniversalPipeline" "RenderType"="Opaque" }

        // We don't need culling or depth testing for a fullscreen effect
        Cull Off ZWrite Off ZTest Always
        // No blending needed unless you specifically want it (usually not for distortion)
        Blend Off

        Pass
        {
            Name "UnderwaterDistortionPass"

            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            // Include URP core library
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl" // May not be strictly needed but good practice

            // Define uniforms matching the Properties block
            sampler2D _MainTex;
            sampler2D _NoiseTex;
            sampler2D _TurbulenceMap;
            float4 _MainTex_ST; // Standard Unity texture scale/translation (needed for vert)

            float _BaseDistortionStrength;
            float _NoiseScale;
            float _NoiseSpeed;
            float _TurbulenceMultiplier;

            // Input structure for the vertex shader
            // Using URP's fullscreen triangle attributes
            struct Attributes
            {
                uint vertexID : SV_VertexID;
                // No other inputs needed for fullscreen triangle
            };

            // Output structure (interpolators) from vertex to fragment shader
            struct Varyings
            {
                float4 vertex : SV_POSITION; // Clip space position
                float2 uv : TEXCOORD0;       // Screen UV coordinates
            };

            // Vertex Shader: Handles the fullscreen triangle generation
            Varyings vert(Attributes input)
            {
                Varyings output = (Varyings)0; // Initialize output

                // URP helper functions to get vertex position and UV for a fullscreen draw
                output.vertex = GetFullScreenTriangleVertexPosition(input.vertexID);
                output.uv = GetFullScreenTriangleTexCoord(input.vertexID);

                // Apply texture scale/offset if needed (usually identity for fullscreen)
                // output.uv = TRANSFORM_TEX(output.uv, _MainTex); // Often not needed here

                return output;
            }

            // Fragment Shader: Performs the distortion logic
            half4 frag(Varyings i) : SV_Target
            {
                // 1. Get screen UV
                float2 screenUV = i.uv;

                // 2. Calculate animated UVs for sampling the noise texture
                //    Scroll noise vertically based on time
                float2 noiseUV = screenUV * _NoiseScale + float2(0.0, _Time.y * _NoiseSpeed);

                // 3. Sample the noise texture (using its Red channel)
                //    Remap from 0..1 range to -1..1 range for centered distortion
                float noiseValue = (tex2D(_NoiseTex, noiseUV).r * 2.0) - 1.0;

                // 4. Sample the turbulence map (using its Red channel)
                //    This map should be black (0) where no turbulence, white (1) where max turbulence
                float turbulenceIntensity = tex2D(_TurbulenceMap, screenUV).r;

                // 5. Calculate the final distortion strength for this pixel
                float currentStrength = _BaseDistortionStrength + (turbulenceIntensity * _TurbulenceMultiplier);

                // 6. Calculate the 2D offset vector based on noise and strength
                //    Using the same noise for x/y gives a simple ripple
                //    For more complex distortion, sample noise again with different UVs or use noise green channel for y offset
                float2 uvOffset = float2(noiseValue, noiseValue) * currentStrength;

                // 7. Calculate the distorted UV coordinates to sample the main screen texture
                float2 distortedUV = screenUV + uvOffset;

                // 8. Sample the main screen texture (_MainTex) using the distorted UVs
                half4 screenColor = tex2D(_MainTex, distortedUV);

                return screenColor;
            }
            ENDHLSL
        }
    }
    Fallback Off // No fallback needed
}